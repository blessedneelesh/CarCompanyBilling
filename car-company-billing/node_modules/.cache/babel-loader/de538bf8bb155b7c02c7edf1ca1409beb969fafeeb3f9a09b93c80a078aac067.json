{"ast":null,"code":"import * as React from 'react';\nimport renderers, { renderBlock, renderInline, renderNoop } from './renderers.js';\nimport { Text, View } from '@react-pdf/renderer';\nimport parseHtml from './parse.js';\nimport { createHtmlStylesheet } from './styles.js';\nimport { isText } from './tags.js';\nconst convertEntities = input => {\n  const entities = [['amp', '&'], ['apos', \"'\"], ['#x27', \"'\"], ['#x2F', '/'], ['#39', \"'\"], ['#47', '/'], ['lt', '<'], ['gt', '>'], ['nbsp', ' '], ['quot', '\"']];\n  let text = input;\n  for (let entity of entities) {\n    text = text.replace(new RegExp('&' + entity[0] + ';', 'g'), entity[1]);\n  }\n  return text;\n};\nexport const isBlockStyle = style => ['block', 'flex'].includes(style.display);\nexport const hasBlockContent = element => {\n  if (typeof element === 'string') {\n    return false;\n  }\n  if (element.tag === 'a' || isText[element.tag]) {\n    if (element.style?.some(isBlockStyle)) {\n      return true;\n    }\n    // anchor tags match their content\n    if (element.content) {\n      return element.content.some(hasBlockContent);\n    }\n    return false;\n  }\n  return true;\n};\nconst ltrim = text => text.replace(/^\\s+/, '');\nconst rtrim = text => text.replace(/\\s+$/, '');\nconst isCustomElement = element => {\n  if (!element || typeof element === 'string') return false;\n  return isText[element.tag] === undefined;\n};\n/**\n * Groups all block and non-block elements into buckets so that all non-block elements can be rendered in a parent Text element\n * @param elements Elements to place in buckets of block and non-block content\n * @param collapse\n * @param parentTag\n */\nexport const bucketElements = (elements, collapse, parentTag) => {\n  let bucket;\n  let hasBlock;\n  const buckets = [];\n  elements.forEach((element, index) => {\n    // clear empty strings between block elements\n    if (typeof element === 'string') {\n      if (collapse) {\n        if (parentTag === 'pre') {\n          if (element[0] === '\\n') {\n            element = element.substr(1);\n          }\n          if (element[element.length - 1] === '\\n') {\n            element = element.substr(0, element.length - 1);\n          }\n        } else {\n          const isBucketCustomElement = isCustomElement(bucket?.content[0]);\n          if (!isBucketCustomElement && (hasBlock || hasBlock === undefined)) {\n            element = ltrim(element);\n          }\n          const next = elements[index + 1];\n          if (next) {\n            const isNextCustomElement = isCustomElement(next);\n            if (hasBlockContent(next) && !isNextCustomElement) {\n              element = rtrim(element);\n            }\n          }\n        }\n      }\n      if (element === '') {\n        return;\n      }\n    }\n    const block = hasBlockContent(element);\n    if (block !== hasBlock || isCustomElement(element)) {\n      hasBlock = block;\n      bucket = {\n        hasBlock,\n        content: []\n      };\n      buckets.push(bucket);\n    }\n    bucket.content.push(element);\n  });\n  return buckets;\n};\nexport const renderElement = (element, stylesheets, renderers, children, index) => {\n  if (typeof element === 'string') {\n    element = convertEntities(element);\n    if (/(\\s )|( \\s)/.test(element)) {\n      // hack to avoid collapsing sequential spaces\n      return element.split(/(\\s{2,})/g).reduce((strings, string, index) => string === '' ? strings : strings.concat(index % 2 ? string.split('') : string), []);\n    }\n    return element;\n  }\n  let Element = renderers[element.tag];\n  if (!Element) {\n    if (!(element.tag in isText)) {\n      // Unknown element, do nothing\n      console.warn(`Excluding \"${element.tag}\" because it has no renderer`);\n      Element = renderNoop;\n    } else {\n      Element = hasBlockContent(element) ? renderBlock : renderInline;\n    }\n  }\n  return React.createElement(Element, {\n    key: index,\n    style: element.style,\n    children: children,\n    element: element,\n    stylesheets: stylesheets\n  });\n};\nexport const collapseWhitespace = string => string.replace(/(\\s+)/g, ' ');\nexport const renderBucketElement = (element, options, index) => {\n  if (typeof element === 'string') {\n    return renderElement(options.collapse ? collapseWhitespace(element) : element, options.stylesheets, options.renderers, undefined, index);\n  }\n  return renderElement(element, options.stylesheets, options.renderers, renderElements(element.content, element.tag === 'pre' ? {\n    ...options,\n    collapse: false\n  } : options, element), index);\n};\nconst isAnchor = content => {\n  return Array.isArray(content) ? content.length === 1 && typeof content[0] !== 'string' && content[0].tag === 'a' : content.tag === 'a';\n};\nconst isSvgText = content => {\n  return ['svg', 'line', 'polyline', 'polygon', 'path', 'rect', 'circle', 'ellipse', 'text', 'tspan', 'g', 'stop', 'defs', 'clippath', 'lineargradient', 'radialgradient'].includes(content?.tag || '');\n};\nexport const renderElements = (elements, options, parent) => {\n  const buckets = bucketElements(elements, options.collapse, parent?.tag);\n  const parentIsText = parent && !isAnchor(parent) && !hasBlockContent(parent) || isSvgText(parent);\n  const renderedBuckets = buckets.map((bucket, bucketIndex) => {\n    const wrapWithText = !bucket.hasBlock && !parentIsText && !isAnchor(bucket.content) && (bucket.content.length > 1 || typeof bucket.content[0] === 'string');\n    // Avoid extra array\n    if (bucket.content.length === 1 && !wrapWithText) {\n      return renderBucketElement(bucket.content[0], options, bucketIndex);\n    }\n    let rendered = bucket.content.map((element, index) => {\n      return renderBucketElement(element, options, index);\n    });\n    // unwrap extra array\n    if (rendered.length === 1) {\n      rendered = rendered[0];\n    }\n    if (wrapWithText) {\n      return React.createElement(Text, {\n        key: bucketIndex\n      }, rendered);\n    } else {\n      return buckets.length === 1 ? rendered : React.createElement(React.Fragment, {\n        key: bucketIndex\n      }, rendered);\n    }\n  });\n  // unwrap extra array\n  return buckets.length === 1 ? renderedBuckets[0] : renderedBuckets;\n};\nexport const applyStylesheets = (stylesheets, rootElement) => {\n  stylesheets.forEach(stylesheet => {\n    for (const selector of Object.keys(stylesheet)) {\n      try {\n        const elements = rootElement.querySelectorAll(selector);\n        elements.forEach(element => {\n          element.style.push(stylesheet[selector]);\n        });\n      } catch (e) {\n        console.warn(`Unable to apply selector \"${selector}\": ${e.message}`);\n      }\n    }\n  });\n};\nconst renderHtml = (text, options = {}) => {\n  const defaultFontSize = 18;\n  const fontSizeStyle = {\n    fontSize: defaultFontSize\n  };\n  const styles = options.style ? Array.isArray(options.style) ? options.style : [options.style] : [];\n  styles.forEach(style => {\n    if (!style) {\n      return;\n    }\n    if (typeof style.fontSize === 'number') {\n      fontSizeStyle.fontSize = style.fontSize;\n    }\n    if (typeof style.fontSize === 'string' && style.fontSize.endsWith('px')) {\n      fontSizeStyle.fontSize = parseInt(style.fontSize, 10);\n    }\n  });\n  const baseStyles = createHtmlStylesheet(fontSizeStyle.fontSize, options.resetStyles);\n  const parsed = parseHtml(text);\n  const stylesheets = options.stylesheet ? Array.isArray(options.stylesheet) ? options.stylesheet : [options.stylesheet] : [];\n  const opts = {\n    collapse: true,\n    resetStyles: false,\n    ...options,\n    renderers: {\n      ...renderers,\n      ...options.renderers\n    },\n    stylesheets: [baseStyles, ...stylesheets, ...parsed.stylesheets]\n  };\n  applyStylesheets(opts.stylesheets, parsed.rootElement);\n  return React.createElement(View, {\n    style: [...styles, fontSizeStyle]\n  }, renderElements(parsed.rootElement.content, opts));\n};\nexport default renderHtml;","map":{"version":3,"names":["React","renderers","renderBlock","renderInline","renderNoop","Text","View","parseHtml","createHtmlStylesheet","isText","convertEntities","input","entities","text","entity","replace","RegExp","isBlockStyle","style","includes","display","hasBlockContent","element","tag","some","content","ltrim","rtrim","isCustomElement","undefined","bucketElements","elements","collapse","parentTag","bucket","hasBlock","buckets","forEach","index","substr","length","isBucketCustomElement","next","isNextCustomElement","block","push","renderElement","stylesheets","children","test","split","reduce","strings","string","concat","Element","console","warn","createElement","key","collapseWhitespace","renderBucketElement","options","renderElements","isAnchor","Array","isArray","isSvgText","parent","parentIsText","renderedBuckets","map","bucketIndex","wrapWithText","rendered","Fragment","applyStylesheets","rootElement","stylesheet","selector","Object","keys","querySelectorAll","e","message","renderHtml","defaultFontSize","fontSizeStyle","fontSize","styles","endsWith","parseInt","baseStyles","resetStyles","parsed","opts"],"sources":["D:\\fullStackProjects\\CarCompanyBilling\\car-company-billing\\node_modules\\react-pdf-html\\src\\render.tsx"],"sourcesContent":["import * as React from 'react';\nimport renderers, {\n  renderBlock,\n  renderInline,\n  renderNoop,\n} from './renderers.js';\nimport { Text, View } from '@react-pdf/renderer';\nimport parseHtml, { HtmlContent, HtmlElement } from './parse.js';\nimport { createHtmlStylesheet, HtmlStyle, HtmlStyles } from './styles.js';\nimport { Style } from '@react-pdf/types';\nimport { isText, Tag } from './tags.js';\n\nexport type HtmlRendererProps = {\n  element: HtmlElement;\n  style: Style[];\n  children: React.ReactNode;\n  stylesheets: HtmlStyles[];\n};\n\nexport type HtmlRenderer = React.FC<React.PropsWithChildren<HtmlRendererProps>>;\n\nexport type WrapperRenderer = (\n  Wrapper: React.ElementType,\n  renderer: HtmlRendererProps\n) => React.ReactElement;\n\nexport type HtmlRenderers = Record<Tag | string, HtmlRenderer>;\n\nexport type HtmlRenderOptions = {\n  collapse: boolean;\n  renderers: HtmlRenderers;\n  stylesheets: HtmlStyles[];\n  resetStyles: boolean;\n};\n\ntype ContentBucket = {\n  hasBlock: boolean;\n  content: HtmlContent;\n};\n\nconst convertEntities = (input: string) => {\n  const entities = [\n    ['amp', '&'],\n    ['apos', \"'\"],\n    ['#x27', \"'\"],\n    ['#x2F', '/'],\n    ['#39', \"'\"],\n    ['#47', '/'],\n    ['lt', '<'],\n    ['gt', '>'],\n    ['nbsp', ' '],\n    ['quot', '\"'],\n  ];\n\n  let text = input;\n  for (let entity of entities) {\n    text = text.replace(new RegExp('&' + entity[0] + ';', 'g'), entity[1]);\n  }\n  return text;\n};\n\nexport const isBlockStyle = (style: HtmlStyle) =>\n  ['block', 'flex'].includes(style.display);\n\nexport const hasBlockContent = (element: HtmlElement | string): boolean => {\n  if (typeof element === 'string') {\n    return false;\n  }\n\n  if (element.tag === 'a' || isText[element.tag]) {\n    if (element.style?.some(isBlockStyle)) {\n      return true;\n    }\n\n    // anchor tags match their content\n    if (element.content) {\n      return element.content.some(hasBlockContent);\n    }\n    return false;\n  }\n\n  return true;\n};\n\nconst ltrim = (text: string): string => text.replace(/^\\s+/, '');\nconst rtrim = (text: string): string => text.replace(/\\s+$/, '');\n\nconst isCustomElement = (element?: HtmlElement | string): boolean => {\n  if (!element || typeof element === 'string') return false;\n  return isText[element.tag] === undefined;\n};\n\n/**\n * Groups all block and non-block elements into buckets so that all non-block elements can be rendered in a parent Text element\n * @param elements Elements to place in buckets of block and non-block content\n * @param collapse\n * @param parentTag\n */\nexport const bucketElements = (\n  elements: HtmlContent,\n  collapse: boolean,\n  parentTag?: Tag | string\n): ContentBucket[] => {\n  let bucket: ContentBucket;\n  let hasBlock: boolean;\n  const buckets: ContentBucket[] = [];\n  elements.forEach((element, index) => {\n    // clear empty strings between block elements\n    if (typeof element === 'string') {\n      if (collapse) {\n        if (parentTag === 'pre') {\n          if (element[0] === '\\n') {\n            element = element.substr(1);\n          }\n          if (element[element.length - 1] === '\\n') {\n            element = element.substr(0, element.length - 1);\n          }\n        } else {\n          const isBucketCustomElement = isCustomElement(bucket?.content[0]);\n          if (!isBucketCustomElement && (hasBlock || hasBlock === undefined)) {\n            element = ltrim(element);\n          }\n          const next = elements[index + 1];\n\n          if (next) {\n            const isNextCustomElement = isCustomElement(next);\n            if (hasBlockContent(next) && !isNextCustomElement) {\n              element = rtrim(element);\n            }\n          }\n        }\n      }\n      if (element === '') {\n        return;\n      }\n    }\n    const block = hasBlockContent(element);\n    if (block !== hasBlock || isCustomElement(element)) {\n      hasBlock = block;\n      bucket = {\n        hasBlock,\n        content: [],\n      };\n      buckets.push(bucket);\n    }\n    bucket.content.push(element);\n  });\n\n  return buckets;\n};\n\ntype RenderedContent =\n  | React.ReactElement\n  | React.ReactElement[]\n  | string\n  | string[];\n\nexport const renderElement = (\n  element: HtmlElement | string,\n  stylesheets: HtmlStyles[],\n  renderers: HtmlRenderers,\n  children?: any,\n  index?: number\n): RenderedContent => {\n  if (typeof element === 'string') {\n    element = convertEntities(element);\n    if (/(\\s )|( \\s)/.test(element)) {\n      // hack to avoid collapsing sequential spaces\n      return element\n        .split(/(\\s{2,})/g)\n        .reduce(\n          (strings, string, index) =>\n            string === ''\n              ? strings\n              : strings.concat(index % 2 ? string.split('') : string),\n          [] as string[]\n        );\n    }\n    return element;\n  }\n  let Element: HtmlRenderer | undefined = renderers[element.tag];\n  if (!Element) {\n    if (!(element.tag in isText)) {\n      // Unknown element, do nothing\n      console.warn(`Excluding \"${element.tag}\" because it has no renderer`);\n      Element = renderNoop;\n    } else {\n      Element = hasBlockContent(element) ? renderBlock : renderInline;\n    }\n  }\n\n  return (\n    <Element\n      key={index}\n      style={element.style}\n      children={children}\n      element={element}\n      stylesheets={stylesheets}\n    />\n  );\n};\n\nexport const collapseWhitespace = (string: any): string =>\n  string.replace(/(\\s+)/g, ' ');\n\nexport const renderBucketElement = (\n  element: HtmlElement | string,\n  options: HtmlRenderOptions,\n  index: number\n): RenderedContent => {\n  if (typeof element === 'string') {\n    return renderElement(\n      options.collapse ? collapseWhitespace(element) : element,\n      options.stylesheets,\n      options.renderers,\n      undefined,\n      index\n    );\n  }\n  return renderElement(\n    element,\n    options.stylesheets,\n    options.renderers,\n    renderElements(\n      element.content,\n      element.tag === 'pre' ? { ...options, collapse: false } : options,\n      element\n    ),\n    index\n  );\n};\n\nconst isAnchor = (content: HtmlContent | HtmlElement): boolean => {\n  return Array.isArray(content)\n    ? content.length === 1 &&\n        typeof content[0] !== 'string' &&\n        content[0].tag === 'a'\n    : content.tag === 'a';\n};\n\nconst isSvgText = (content: HtmlElement | undefined): boolean => {\n  return [\n    'svg',\n    'line',\n    'polyline',\n    'polygon',\n    'path',\n    'rect',\n    'circle',\n    'ellipse',\n    'text',\n    'tspan',\n    'g',\n    'stop',\n    'defs',\n    'clippath',\n    'lineargradient',\n    'radialgradient',\n  ].includes(content?.tag || '');\n};\n\nexport const renderElements = (\n  elements: HtmlContent,\n  options: HtmlRenderOptions,\n  parent?: HtmlElement\n): RenderedContent | RenderedContent[] => {\n  const buckets = bucketElements(elements, options.collapse, parent?.tag);\n  const parentIsText =\n    (parent && !isAnchor(parent) && !hasBlockContent(parent)) ||\n    isSvgText(parent);\n\n  const renderedBuckets: (RenderedContent[] | RenderedContent)[] = buckets.map(\n    (bucket, bucketIndex) => {\n      const wrapWithText =\n        !bucket.hasBlock &&\n        !parentIsText &&\n        !isAnchor(bucket.content) &&\n        (bucket.content.length > 1 || typeof bucket.content[0] === 'string');\n\n      // Avoid extra array\n      if (bucket.content.length === 1 && !wrapWithText) {\n        return renderBucketElement(bucket.content[0], options, bucketIndex);\n      }\n\n      let rendered: RenderedContent | RenderedContent[] = bucket.content.map(\n        (element, index) => {\n          return renderBucketElement(element, options, index);\n        }\n      );\n\n      // unwrap extra array\n      if (rendered.length === 1) {\n        rendered = rendered[0];\n      }\n\n      if (wrapWithText) {\n        return <Text key={bucketIndex}>{rendered}</Text>;\n      } else {\n        return buckets.length === 1 ? (\n          rendered\n        ) : (\n          <React.Fragment key={bucketIndex}>{rendered}</React.Fragment>\n        );\n      }\n    }\n  );\n\n  // unwrap extra array\n  return buckets.length === 1\n    ? (renderedBuckets[0] as RenderedContent)\n    : (renderedBuckets as RenderedContent[]);\n};\n\nexport const applyStylesheets = (\n  stylesheets: HtmlStyles[],\n  rootElement: HtmlElement\n) => {\n  stylesheets.forEach((stylesheet) => {\n    for (const selector of Object.keys(stylesheet)) {\n      try {\n        const elements = rootElement.querySelectorAll(\n          selector\n        ) as HtmlElement[];\n        elements.forEach((element) => {\n          element.style.push(stylesheet[selector]);\n        });\n      } catch (e) {\n        console.warn(\n          `Unable to apply selector \"${selector}\": ${(e as Error).message}`\n        );\n      }\n    }\n  });\n};\n\nconst renderHtml = (\n  text: string,\n  options: {\n    collapse?: boolean;\n    renderers?: HtmlRenderers;\n    style?: Style | Style[];\n    stylesheet?: HtmlStyles | HtmlStyles[];\n    resetStyles?: boolean;\n  } = {}\n): React.ReactElement => {\n  const defaultFontSize = 18;\n  const fontSizeStyle = { fontSize: defaultFontSize };\n  const styles = options.style\n    ? Array.isArray(options.style)\n      ? options.style\n      : [options.style]\n    : [];\n\n  styles.forEach((style) => {\n    if (!style) {\n      return;\n    }\n    if (typeof style.fontSize === 'number') {\n      fontSizeStyle.fontSize = style.fontSize;\n    }\n    if (typeof style.fontSize === 'string' && style.fontSize.endsWith('px')) {\n      fontSizeStyle.fontSize = parseInt(style.fontSize, 10);\n    }\n  });\n  const baseStyles = createHtmlStylesheet(\n    fontSizeStyle.fontSize,\n    options.resetStyles\n  );\n  const parsed = parseHtml(text);\n\n  const stylesheets = options.stylesheet\n    ? Array.isArray(options.stylesheet)\n      ? options.stylesheet\n      : [options.stylesheet]\n    : [];\n\n  const opts: HtmlRenderOptions = {\n    collapse: true,\n    resetStyles: false,\n    ...options,\n    renderers: { ...renderers, ...options.renderers },\n    stylesheets: [baseStyles, ...stylesheets, ...parsed.stylesheets],\n  };\n\n  applyStylesheets(opts.stylesheets, parsed.rootElement);\n\n  return (\n    <View style={[...styles, fontSizeStyle]}>\n      {renderElements(parsed.rootElement.content, opts)}\n    </View>\n  );\n};\n\nexport default renderHtml;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}