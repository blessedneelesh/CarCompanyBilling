{"ast":null,"code":"import { NodeType, parse } from 'node-html-parser';\nimport * as cssTree from 'css-tree';\nconst {\n  generate,\n  parse: cssParse\n} = cssTree;\nimport supportedStyles from './supportedStyles.js';\nimport camelize from './camelize.js';\nexport const convertRule = (rule, source = 'style') => {\n  const declarations = rule.children.filter(declaration => declaration.type === 'Declaration').toArray();\n  return declarations.map(entry => ({\n    ...entry,\n    property: camelize(entry.property)\n  })).reduce((style, {\n    property,\n    value\n  }) => {\n    let valueString = generate(value);\n    if (property && value) {\n      if (property === 'fontFamily') {\n        valueString = valueString.replace(/[\"']+/g, '');\n        if (valueString.includes(',')) {\n          const reduced = valueString.split(',', 2)[0];\n          console.warn(`react-pdf doesn't support fontFamily lists like \"${valueString}\". Reducing to \"${reduced}\".`);\n          valueString = reduced;\n        }\n      } else if (!supportedStyles.includes(property)) {\n        if (property === 'background' && /^#?[a-zA-Z0-9]+$/.test(valueString) || /^rgba?\\([0-9, ]+\\)$/i.test(valueString) || /^hsla?\\([0-9.%, ]+\\)$/i.test(valueString)) {\n          property = 'backgroundColor';\n        } else {\n          console.warn(`${source}: Found unsupported style \"${property}\"`, {\n            property,\n            value\n          });\n        }\n      }\n      style[property] = valueString;\n    }\n    return style;\n  }, {});\n};\nexport const convertStylesheet = stylesheet => {\n  const response = {};\n  try {\n    const parsed = cssParse(stylesheet);\n    const rules = parsed.children.filter(rule => rule.type === 'Rule' && rule.prelude?.type === 'SelectorList');\n    rules.forEach(rule => {\n      const style = convertRule(rule.block);\n      if (rule.prelude.type !== 'SelectorList') {\n        return;\n      }\n      rule.prelude.children.forEach(selector => {\n        const selectorString = generate(selector);\n        if (selectorString.includes('::')) {\n          // skip pseudo-elements\n          return;\n        }\n        response[selectorString] = style;\n      });\n    });\n  } catch (e) {\n    console.error(`Error parsing stylesheet: \"${stylesheet}\"`, e);\n  }\n  return response;\n};\nexport const convertElementStyle = (styleAttr, tag) => {\n  try {\n    const parsed = cssParse(`${tag} { ${styleAttr} }`);\n    const rules = parsed.children.filter(rule => rule.type === 'Rule' && rule.prelude?.type === 'SelectorList');\n    const firstRule = rules?.first();\n    return firstRule ? convertRule(firstRule.block, tag) : undefined;\n  } catch (e) {\n    console.error(`Error parsing style attribute \"${styleAttr}\" for tag: ${tag}`, e);\n  }\n};\nexport const convertNode = node => {\n  if (node.nodeType === NodeType.TEXT_NODE) {\n    return node.rawText;\n  }\n  if (node.nodeType === NodeType.COMMENT_NODE) {\n    return '';\n  }\n  if (node.nodeType !== NodeType.ELEMENT_NODE) {\n    throw new Error('Not sure what this is');\n  }\n  const html = node;\n  const content = html.childNodes.map(convertNode);\n  const kindCounters = {};\n  content.forEach(child => {\n    if (typeof child !== 'string') {\n      child.indexOfType = child.tag in kindCounters ? kindCounters[child.tag] = kindCounters[child.tag] + 1 : kindCounters[child.tag] = 0;\n    }\n  });\n  let style;\n  if (html.attributes.style && html.attributes.style.trim()) {\n    style = convertElementStyle(html.attributes.style, html.tagName);\n  }\n  return Object.assign(html, {\n    tag: (html.tagName || '').toLowerCase(),\n    style: style ? [style] : [],\n    content,\n    indexOfType: 0\n  });\n};\nconst parseHtml = text => {\n  const html = parse(text, {\n    comment: false\n  });\n  const stylesheets = html.querySelectorAll('style').map(styleNode => styleNode.childNodes.map(textNode => textNode.rawText.trim()).join('\\n')).filter(styleText => !!styleText).map(convertStylesheet);\n  return {\n    stylesheets,\n    rootElement: convertNode(html)\n  };\n};\nexport default parseHtml;","map":{"version":3,"names":["NodeType","parse","cssTree","generate","cssParse","supportedStyles","camelize","convertRule","rule","source","declarations","children","filter","declaration","type","toArray","map","entry","property","reduce","style","value","valueString","replace","includes","reduced","split","console","warn","test","convertStylesheet","stylesheet","response","parsed","rules","prelude","forEach","block","selector","selectorString","e","error","convertElementStyle","styleAttr","tag","firstRule","first","undefined","convertNode","node","nodeType","TEXT_NODE","rawText","COMMENT_NODE","ELEMENT_NODE","Error","html","content","childNodes","kindCounters","child","indexOfType","attributes","trim","tagName","Object","assign","toLowerCase","parseHtml","text","comment","stylesheets","querySelectorAll","styleNode","textNode","join","styleText","rootElement"],"sources":["D:\\fullStackProjects\\CarCompanyBilling\\car-company-billing\\node_modules\\react-pdf-html\\src\\parse.ts"],"sourcesContent":["import {\n  HTMLElement,\n  Node as HTMLNode,\n  NodeType,\n  parse,\n  TextNode,\n} from 'node-html-parser';\nimport { Tag } from './tags.js';\nimport { Block, Declaration, List, Rule, StyleSheet } from 'css-tree';\nimport * as cssTree from 'css-tree';\nconst { generate, parse: cssParse } = cssTree;\n\nimport supportedStyles from './supportedStyles.js';\nimport { HtmlStyle, HtmlStyles } from './styles.js';\nimport camelize from './camelize.js';\n\nexport type HtmlContent = (HtmlElement | string)[];\n\nexport type HtmlElement = HTMLElement & {\n  tag: Tag | 'string';\n  parentNode: HtmlElement;\n  style: HtmlStyle[];\n  content: HtmlContent;\n  indexOfType: number;\n  querySelectorAll: (selector: string) => HtmlElement[];\n  querySelector: (selector: string) => HtmlElement;\n};\n\nexport const convertRule = (\n  rule: Block,\n  source: string = 'style'\n): HtmlStyle => {\n  const declarations = rule.children\n    .filter((declaration) => declaration.type === 'Declaration')\n    .toArray() as Declaration[];\n\n  return declarations\n    .map((entry) => ({\n      ...entry,\n      property: camelize(entry.property as string),\n    }))\n    .reduce((style, { property, value }: Declaration) => {\n      let valueString = generate(value);\n      if (property && value) {\n        if (property === 'fontFamily') {\n          valueString = valueString.replace(/[\"']+/g, '');\n          if (valueString.includes(',')) {\n            const reduced = valueString.split(',', 2)[0];\n            console.warn(\n              `react-pdf doesn't support fontFamily lists like \"${valueString}\". Reducing to \"${reduced}\".`\n            );\n            valueString = reduced;\n          }\n        } else if (!supportedStyles.includes(property)) {\n          if (\n            (property === 'background' &&\n              /^#?[a-zA-Z0-9]+$/.test(valueString)) ||\n            /^rgba?\\([0-9, ]+\\)$/i.test(valueString) ||\n            /^hsla?\\([0-9.%, ]+\\)$/i.test(valueString)\n          ) {\n            property = 'backgroundColor';\n          } else {\n            console.warn(`${source}: Found unsupported style \"${property}\"`, {\n              property,\n              value,\n            });\n          }\n        }\n\n        style[property as keyof HtmlStyle] = valueString;\n      }\n      return style;\n    }, {} as HtmlStyle);\n};\n\nexport const convertStylesheet = (stylesheet: string): HtmlStyles => {\n  const response = {} as HtmlStyles;\n  try {\n    const parsed = cssParse(stylesheet) as StyleSheet;\n    const rules = parsed.children.filter(\n      (rule) => rule.type === 'Rule' && rule.prelude?.type === 'SelectorList'\n    ) as List<Rule>;\n    rules.forEach((rule) => {\n      const style = convertRule(rule.block);\n      if (rule.prelude.type !== 'SelectorList') {\n        return;\n      }\n      rule.prelude.children.forEach((selector) => {\n        const selectorString = generate(selector);\n        if (selectorString.includes('::')) {\n          // skip pseudo-elements\n          return;\n        }\n        response[selectorString] = style;\n      });\n    });\n  } catch (e) {\n    console.error(`Error parsing stylesheet: \"${stylesheet}\"`, e);\n  }\n  return response;\n};\n\nexport const convertElementStyle = (\n  styleAttr: string,\n  tag: string\n): HtmlStyle | undefined => {\n  try {\n    const parsed = cssParse(`${tag} { ${styleAttr} }`) as StyleSheet;\n    const rules = parsed.children.filter(\n      (rule) => rule.type === 'Rule' && rule.prelude?.type === 'SelectorList'\n    ) as List<Rule>;\n    const firstRule = rules?.first();\n    return firstRule ? convertRule(firstRule.block, tag) : undefined;\n  } catch (e) {\n    console.error(\n      `Error parsing style attribute \"${styleAttr}\" for tag: ${tag}`,\n      e\n    );\n  }\n};\n\nexport const convertNode = (node: HTMLNode): HtmlElement | string => {\n  if (node.nodeType === NodeType.TEXT_NODE) {\n    return (node as TextNode).rawText;\n  }\n  if (node.nodeType === NodeType.COMMENT_NODE) {\n    return '';\n  }\n  if (node.nodeType !== NodeType.ELEMENT_NODE) {\n    throw new Error('Not sure what this is');\n  }\n  const html = node as HTMLElement;\n  const content = html.childNodes.map(convertNode);\n  const kindCounters: Record<string, number> = {};\n  content.forEach((child) => {\n    if (typeof child !== 'string') {\n      child.indexOfType =\n        child.tag in kindCounters\n          ? (kindCounters[child.tag] = kindCounters[child.tag] + 1)\n          : (kindCounters[child.tag] = 0);\n    }\n  });\n\n  let style: HtmlStyle | undefined;\n  if (html.attributes.style && html.attributes.style.trim()) {\n    style = convertElementStyle(html.attributes.style, html.tagName);\n  }\n\n  return Object.assign(html, {\n    tag: (html.tagName || '').toLowerCase() as Tag | string,\n    style: style ? [style] : [],\n    content,\n    indexOfType: 0,\n  }) as HtmlElement;\n};\n\nconst parseHtml = (\n  text: string\n): { stylesheets: HtmlStyles[]; rootElement: HtmlElement } => {\n  const html = parse(text, { comment: false });\n\n  const stylesheets = html\n    .querySelectorAll('style')\n    .map((styleNode) =>\n      styleNode.childNodes.map((textNode) => textNode.rawText.trim()).join('\\n')\n    )\n    .filter((styleText) => !!styleText)\n    .map(convertStylesheet);\n  return {\n    stylesheets,\n    rootElement: convertNode(html) as HtmlElement,\n  };\n};\n\nexport default parseHtml;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}