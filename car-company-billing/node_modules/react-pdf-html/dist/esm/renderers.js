import * as React from 'react';
import { Circle, ClipPath, Defs, Ellipse, G, Image, Line, LinearGradient, Link, Path, Polygon, Polyline, RadialGradient, Rect, Stop, Svg, Text, Tspan, View, } from '@react-pdf/renderer';
import { lowerAlpha, orderedAlpha, upperAlpha } from './ordered.type.js';
import camelize from './camelize.js';
export const renderNoop = ({ children }) => React.createElement(React.Fragment, null);
export const renderPassThrough = ({ children, }) => children;
const convertSvgAttributes = (attrs) => {
    const result = {};
    for (const key in attrs) {
        result[camelize(key)] = attrs[key];
    }
    return result;
};
const convertSvgStyles = (stylesTags) => {
    return stylesTags.reduce((acc, cur) => ({ ...acc, ...cur }), {});
};
export const renderSvgs = (Wrapper, { element, style, children }) => {
    return (React.createElement(Wrapper, { ...convertSvgAttributes(element?.attributes), ...convertSvgStyles(style) }, children));
};
export const renderBlock = ({ style, children }) => (React.createElement(View, { style: style }, children));
export const renderInline = ({ style, children }) => (React.createElement(Text, { style: style }, children));
export const renderCell = ({ style, element, children }) => {
    const table = element.closest('table');
    if (!table) {
        throw new Error('td element rendered outside of a table');
    }
    const tableStyles = table.style.reduce((combined, tableStyle) => Object.assign(combined, tableStyle), {});
    const baseStyles = {
        border: tableStyles.border,
        borderColor: tableStyles.borderColor,
        borderWidth: tableStyles.borderWidth,
        borderStyle: tableStyles.borderStyle,
    };
    if (tableStyles.borderSpacing &&
        tableStyles.borderCollapse !== 'collapse') {
        baseStyles.width = tableStyles.borderWidth;
        baseStyles.margin = tableStyles.borderSpacing;
    }
    else {
        baseStyles.borderRightWidth = 0;
        baseStyles.borderBottomWidth = 0;
        if (element.indexOfType !== 0) {
            baseStyles.borderLeftWidth = tableStyles.borderWidth;
            baseStyles.borderTopWidth = tableStyles.borderWidth;
        }
    }
    const overrides = {};
    if (element.attributes && element.attributes.colspan) {
        const colspan = parseInt(element.attributes.colspan, 10);
        if (!isNaN(colspan)) {
            overrides.flexBasis = colspan;
        }
    }
    return React.createElement(View, { style: [baseStyles, ...style, overrides] }, children);
};
const renderers = {
    style: renderNoop,
    script: renderNoop,
    html: renderPassThrough,
    li: ({ element, stylesheets, style, children }) => {
        const bulletStyles = stylesheets.map((stylesheet) => stylesheet.li_bullet);
        const contentStyles = stylesheets.map((stylesheet) => stylesheet.li_content);
        const list = element.closest('ol, ul');
        const ordered = list?.tag === 'ol' || element.parentNode.tag === 'ol';
        const listStyle = list?.style?.reduce((combined, listStyle) => Object.assign(combined, listStyle), {}) || {};
        const itemStyle = element.style.reduce((combined, itemStyle) => Object.assign(combined, itemStyle), {});
        const listStyleType = itemStyle.listStyleType ||
            itemStyle.listStyle ||
            listStyle.listStyleType ||
            listStyle.listStyle ||
            '';
        let bullet;
        if (listStyleType.includes('none')) {
            bullet = false;
        }
        else if (listStyleType.includes('url(')) {
            bullet = (React.createElement(Image, { src: listStyleType.match(/\((.*?)\)/)[1].replace(/(['"])/g, '') }));
        }
        else if (ordered) {
            if (lowerAlpha.includes(listStyleType)) {
                bullet = (React.createElement(Text, null,
                    orderedAlpha[element.indexOfType].toLowerCase(),
                    "."));
            }
            else if (upperAlpha.includes(listStyleType)) {
                bullet = (React.createElement(Text, null,
                    orderedAlpha[element.indexOfType].toUpperCase(),
                    "."));
            }
            else {
                bullet = React.createElement(Text, null,
                    element.indexOfType + 1,
                    ".");
            }
        }
        else {
            // if (listStyleType.includes('square')) {
            //   bullet = <Text>â– </Text>;
            // } else {
            bullet = React.createElement(Text, null, "\u2022");
            // }
        }
        return (React.createElement(View, { style: style },
            bullet && React.createElement(View, { style: bulletStyles }, bullet),
            React.createElement(View, { style: contentStyles }, children)));
    },
    a: ({ style, element, children }) => (React.createElement(Link, { style: style, src: element.attributes.href }, children)),
    img: ({ style, element }) => (React.createElement(Image, { style: style, source: {
            uri: element.attributes.src,
            body: null,
            method: 'GET',
            headers: {
                'Access-Control-Allow-Origin': '*',
            },
        } })),
    table: ({ element, style, children }) => {
        const tableStyles = element.style.reduce((combined, tableStyle) => Object.assign(combined, tableStyle), {});
        const overrides = {};
        if (!tableStyles.borderSpacing ||
            tableStyles.borderCollapse === 'collapse') {
            overrides.borderLeftWidth = 0;
            overrides.borderTopWidth = 0;
        }
        return React.createElement(View, { style: [...style, overrides] }, children);
    },
    tr: ({ style, children }) => (React.createElement(View, { wrap: false, style: style }, children)),
    br: ({ style }) => (React.createElement(Text, { wrap: false, style: style }, '\n')),
    td: renderCell,
    th: renderCell,
    svg: renderSvgs.bind(null, Svg),
    line: renderSvgs.bind(null, Line),
    polyline: renderSvgs.bind(null, Polyline),
    polygon: renderSvgs.bind(null, Polygon),
    path: renderSvgs.bind(null, Path),
    rect: renderSvgs.bind(null, Rect),
    circle: renderSvgs.bind(null, Circle),
    ellipse: renderSvgs.bind(null, Ellipse),
    text: renderSvgs.bind(null, Text),
    tspan: renderSvgs.bind(null, Tspan),
    g: renderSvgs.bind(null, G),
    stop: renderSvgs.bind(null, Stop),
    defs: renderSvgs.bind(null, Defs),
    clippath: renderSvgs.bind(null, ClipPath),
    lineargradient: renderSvgs.bind(null, LinearGradient),
    radialgradient: renderSvgs.bind(null, RadialGradient),
};
export default renderers;
//# sourceMappingURL=renderers.js.map